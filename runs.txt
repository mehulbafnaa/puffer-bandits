Here’s a structured, “ready-to-run” catalog of runs, grouped by environment and algorithm, with sane defaults for Mac (MPS) and easy switches for CPU/CUDA. It follows SWE best practices: smoke → correctness → performance → plotting/sweeps, with clear knobs and constraints.

Conventions

Device: replace --device mps with cpu or cuda as needed.
Workers: keep --runs divisible by --num-workers (MP mode).
Seeds: add --seed N to fix randomness.
TUI: use native runner (puffer-bandits-native) with --tui for in-terminal dashboards.
Plots/CSV: use classic/advanced runners (puffer-bandits-runner, puffer-bandits-advanced) to save figures and CSVs.
Non‑Contextual (Bernoulli)

Stationary (TUI, serial):
uv run puffer-bandits-native --env bernoulli --algo klucb --k 10 --T 600 --runs 512 --vector serial --device mps --tui --log-every 20
Stationary (TUI, MP throughput):
uv run puffer-bandits-native --env bernoulli --algo klucb --k 10 --T 2000 --runs 1024 --vector mp --num-workers 8 --device mps --tui --log-every 100
Non‑stationary (Discounted UCB, TUI):
uv run puffer-bandits-native --env bernoulli --algo ducb --k 10 --T 1000 --runs 512 --vector serial --device mps --tui --log-every 20 --nonstationary --sigma 0.1
Non‑stationary S
uv run puffer-bandits-native --env bernoulli --algo swucb --k 10 --T 1000 --runs 512 --vector serial --device mps --tui --log-every 20
Contextual (Linear)

LinUCB (TUI, serial):
uv run puffer-bandits-native --env contextual --algo linucb --k 10 --d 8 --T 600 --runs 256 --vector serial --device mps --tui --log-every 10 --alpha 1.0 --lam 1.0
LinTS (TUI, MP throughput):
uv run puffer-bandits-native --env contextual --algo lints --k 10 --d 8 --T 1000 --runs 1024 --vector mp --num-workers 8 --device mps --tui --log-every 50 --v 0.1 --lam 1.0
Contextual (Neural)

NeuralTS (TUI; reduce runs for speed):
uv run puffer-bandits-native --env contextual --algo neuralts --k 10 --d 8 --T 600 --runs 256 --vector mp --num-workers 8 --device mps --tui --log-every 50 --ensembles 3 --hidden 128 --depth 2 --dropout 0.1
NeuralLinearTS (TUI; modest feature dim):
uv run puffer-bandits-native --env contextual --algo neurallinear --k 10 --d 8 --T 600 --runs 256 --vector mp --num-workers 8 --device mps --tui --log-every 50 --features 32 --linlam 1.0 --linv 0.1
Adversarial‑style (Bernoulli)

EXP3 (vectorized with plots/CSV):
uv run puffer-bandits-advanced --env bernoulli --algo exp3 --k 10 --T 1000 --runs 1024 --device mps --num-workers 8 --log-every 200 --save-csv
EXP3‑IX (vectorized with plots/CSV):
uv run puffer-bandits-advanced --env bernoulli --algo exp3ix --k 10 --T 1000 --runs 1024 --device mps --num-workers 8 --log-every 200 --save-csv
Classic “Plotting” Runs (Figures + CSVs)

Bernoulli KL‑UCB:
uv run puffer-bandits-runner --algo klucb --k 10 --T 2000 --runs 1024 --device mps --num-workers 8 --log-every 200 --save-csv
Contextual LinUCB:
uv run puffer-bandits-advanced --env contextual --algo linucb --k 10 --d 8 --T 1000 --runs 1024 --device mps --num-workers 8 --log-every 200 --save-csv
Contextual LinTS (with v,lam annotations):
uv run puffer-bandits-advanced --env contextual --algo lints --k 10 --d 8 --T 1000 --runs 1024 --device mps --num-workers 8 --log-every 200 --save-csv
Profiling / Performance

Non‑contextual (profile prints):
uv run puffer-bandits-runner --algo klucb --k 10 --T 2000 --runs 1024 --device mps --num-workers 8 --profile --log-every 200
Advanced contextual (profile prints, LinUCB):
uv run puffer-bandits-advanced --env contextual --algo linucb --k 10 --d 8 --T 1000 --runs 1024 --device mps --num-workers 8 --profile --log-every 200
Native TUI (serial; speed/steps/sec in TUI):
uv run puffer-bandits-native --env contextual --algo linucb --k 10 --d 8 --T 600 --runs 256 --vector serial --device mps --tui --log-every 10
Smoke / CI‑friendly

Minimal serial sanity checks:
uv run puffer-bandits-native --env bernoulli --algo klucb --k 5 --T 50 --runs 16 --vector serial --device cpu --tui --log-every 10
uv run puffer-bandits-native --env contextual --algo linucb --k 5 --d 3 --T 50 --runs 16 --vector serial --device cpu --tui --log-every 10
Sweeps & Plots (batch)

All‑in sweep script (already added):
bash scripts/run_all.sh mps
Plot a sweep:
uv run python puffer_bandits/plot_sweeps.py --file plots/summary.csv --algo klucb --param c --out plots/sweep_klucb_c.png
uv run python puffer_bandits/plot_sweeps.py --file plots/advanced_summary.csv --algo linucb --param alpha --out plots/sweep_linucb_alpha.png
Hyperparameter Ranges (guidance)

KLUCB: alpha ~ 1.0–3.0
DUCB: discount ~ 0.95–0.995; c ~ 1.0–3.0
SWUCB: window ~ 100–500; c ~ 1.0–3.0
LinUCB: alpha ~ 0.5–2.0; lam ~ 0.1–10
LinTS: v ~ 0.05–0.2; lam ~ 0.1–10
NeuralTS: ensembles 3–7; hidden 64–256; depth 1–3; dropout 0–0.2
NeuralLinearTS: features 32–128; linlam 0.1–10; linv 0.05–0.2
EXP3/IX: gamma ~ 0.03–0.1 (IX uses gamma/k in update)
Best‑practice “Run Matrix” (optional)

Keep a single source of runs (bash or YAML) that enumerates (env × algo × size × device) and invoke with a tiny harness:
bash (scripts/run_all.sh already strong): add arrays for SEEDS=(0 1 2) and loop over them.
YAML (future): a sweeps.yaml consumed by a small Python launcher to iterate and log.
If you want, I can extend scripts/run_all.sh to:

Add CPU/MPS/CUDA device matrix with seeds
Split out “smoke”, “throughput”, and “neural” profiles into sections
Optionally parameterize alpha, v, gamma, etc., per run class
